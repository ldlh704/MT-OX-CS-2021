
\newcommand\thmpl{ 
\begin{theorem}[M. Sipser, p125] \newline
If A is a context-free language, then there is a number $p$ (the pumping length) where, if $s$ is any string in A of length at least $p$, then $s$ may be divided into five pieces $s = uvxyz$ satisfying the conditions 
\begin{enumerate}
    \item for each $i \geq 0, uv^ixy^iz \in A$,
    \item $|vy| > 0$, and
    \item $|vxy| \leq p$.
\end{enumerate}
\label{theorem:cfldef}
\end{theorem}
\hline
}

\newcommand\defcfl{ 
\begin{definition}[Context-Free Language (CFL)] \label{Sipser p103}[M. Sipser, p103] \newline
 Any language that can be generated by some context-free grammar is \textbf{\emph{called a context-free language}}
 \end{definition}
 }

\newcommand\defpa{
\begin{definition}[Pushdown Automaton] \label{Sipser p113}[M. Sipser, p113] \newline
A \textbf{\emph{pushdown automaton}} is a 6-tuple ($Q,\Sigma, \Gamma, \delta, q_{0}, F$), where $Q, \Sigma, \Gamma, and F$ are all finite sets, and
\begin{enumerate}
    \item $Q$ is the set of states,
    \item $\Sigma$ is the input alphabet,
    \item $\Gamma$ is the stack alphabet,
    \item $\delta: Q \cross \Sigma_\varepsilon \cross \Gamma_\varepsilon \longrightarrow \mathcal{P}(Q \cross \Gamma_\varepsilon)$ is the transition function,
    \item $q_0 \in Q$ is the start state, and
    \item $F \subseteq Q $ is the set of accept states.
\end{enumerate}
\end{definition}
}

\newcommand\defcfg{ 
\begin{definition}[Context-Free Grammar (CFG)] \label{Sipser p104}[M. Sipser, p104] \newline
A \textbf{\emph{context-free grammar}} is a 4-tuple ($V,\Sigma, R, S$), where \begin{enumerate}
    \item $V$ is a finite set called the \textbf{\emph{variables,}}
    \item $\Sigma$ is a finite set, disjoint from $V$, called the \textbf{\emph{terminals,}}
    \item $R$ is a finite set of \textbf{\emph{rules}}, with each rule being a variable and a string variables and terminals, and
    \item $S \in V$ is the start variable.
\end{enumerate}
\end{definition}
}

\newcommand\defcnf{
\begin{definition}[Chomsky-Normal Form] \label{Sipser p109 (1)}[M. Sipser, p109] \newline
A context-free grammar is in \textbf{\emph{Chomsky normal form}} if every rule is
of the form \[
A \rightarrow BC \] \[ A \rightarrow a \]
where $a$ is any terminal and $A$, $B$, and $C$ are any variables — except that $B$ and $C$ may not be the start variable. In addition, we permit the rule $S \rightarrow \epsilon$ , where $S$ is the start variable.
\end{definition}
}
\newcommand\thmtrytch{
\begin{theorem}[] \label{Sipser p109 (2)}[M. Sipser, p109] \newline
 Any context-free language is generated by a context-free grammar in Chomsky Normal Form (CNF).
 \end{theorem}
 \\
\begin{theorem}[] \label{Sipser p117}[M. Sipser, p117] \newline
A language is context free if and only if some pushdown automaton recognizes it.
\end{theorem}
\\
\begin{lemma}[] \label{Sipser p117}[M. Sipser, p117] \newline
 If a language is context-free, iff some Pushdown Automaton recognises it.
 \end{lemma}
 \\
\begin{lemma}[] \label{Sipser p121}[M. Sipser, p121] \newline
A pushdown automaton recognizes some language iff 
\end{lemma}
\\
}
\newcommand\defreg{
\begin{definition}[Regular Language] \label{Sipser p40}[M. Sipser, p40]
A language is regular if some finite automaton recognises it.
\end{definition}
\\
\begin{definition}[Regular Expression] \label{Sipser p64}[M. Sipser, p64] \newline
R is a \emph{regular expression} if R is 
\begin{itemize}
\item $a$ for some $a$ in the alphabet $\Sigma$
\item $\epsilon$ - the empty string (NFAs only)
\item $\theta$ - the empty language (contains no strings, not $\epsilon$)
\item $\left( R_{1}\cup R_{2}\right)  \  where\  R_{1}\  and\  R_{2}\  are\  regular\  expressions$
\item $\left( R_{1}\circ R_{2}\right)  \  where\  R_{1}\  and\  R_{2}\  are\  regular\  expressions,\  or$
\item $\left( R^{\ast }_{1}\right)  ,\  where\  R_{1}\  is\  a\  regular\  expression$
\end{itemize}
\end{definition}
}

\newcommand\thmequiv{
\begin{theorem}[DFA, NFA equivalence] \label{Sipser p55}[M. Sipser, p55]
Every NFA has an equivalent DFA.\\
\emph{remark:} In the proof of Q2 we define 9?) a NFA, and so it recognises every language that some DFA can
\end{theorem}
}
\newcommand\defkleene{
\begin{definition}[Kleene Star] \label{Sipser p999}[M. Sipser, p999]
Let $L$ be a language, then the Kleene star is the set of strings \[L^{*}:=\left\{ x_{1}x_{2}x_{3}...x_{k}\  |\  k\geq 0\  and\  each\  x_{i}\in A\right\}  \]
\end{definition}
\\
\begin{theorem}[Closure of Regular Languages under Kleene Star] \label{Sipser p999}[M. Sipser, Orange p999]
The class of regular languages is closed under the Kleene Star operation.
\end{theorem}

\begin{theorem}[Kleene's theorem] \label{Sipser p66}[M. Sipser, p66]
A language is regular if and only if some regular expression describes it. 
\end{theorem}
}

\newcommand\deftotorder{

\begin{definition}[Totally ordered collection of elements]


\end{definition}
}
\newcommand\defconvex{
Antimatroids can also be supersolvable lattices. A supersolvable antimatroid is defined by a totally ordered collection of elements, and a family of sets of these elements. The family must include the empty set. Additionally, it must have the property that if two sets A and B belong to the family, the set-theoretic difference B \ A is nonempty, and x is the smallest element of B \ A, then A ∪ {x} also belongs to the family. As Armstrong observes, any family of sets of this type forms an antimatroid. Armstrong also provides a lattice-theoretic characterization of the antimatroids that this construction can form.
}
\newcommand\defpmpset{}
\newcommand\thmarmstrong{}